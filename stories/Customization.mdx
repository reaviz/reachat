import { Meta } from '@storybook/addon-docs';
import diagram from './architecture.png';

<Meta title="Docs/Customization" />

## Customization
reachat is completely customizable. You can change the look and feel of the chat by
customizing the theme or by providing your own components. Components can even be overriden using
[slots](https://radix-ui.com/docs/primitives/slots).

### Diagram
Below is a diagram of the components that make up the package.

<img src={diagram} alt="Architecture" width="50%" style={{ margin: '0 auto' }} />

### Example
Below is example markup that creates a custom session empty message and also
provides a custom session list item.

```tsx
const CustomSessionMessage: FC<any> = ({
  question,
  response
}) => (
  <div className="p-4 border border-blue-500 rounded mb-4">
    <span className="text-lg font-semibold text-blue-500">
      This is my question: {question}
    </span>
    <br />
    This is the response: {response}
  </div>
);

const CustomSessionListItem: FC<SessionListItemProps> = ({ session }) => {
  const [open, setOpen] = useState(false);
  const btnRef = useRef(null);
  return (
    <>
      <ListItem
        end={
          <IconButton
            ref={btnRef}
            size="small"
            variant="text"
            onClick={e => {
              e.stopPropagation();
              setOpen(true);
            }}
          >
            <MenuIcon />
          </IconButton>
        }
      >
        <span className="truncate">{session.title}</span>
      </ListItem>
      <Menu open={open} onClose={() => setOpen(false)} reference={btnRef}>
        <Card disablePadding>
          <List>
            <ListItem onClick={() => alert('rename')}>Rename</ListItem>
            <ListItem onClick={() => alert('delete')}>Delete</ListItem>
          </List>
        </Card>
      </Menu>
    </>
  );
};
```

Then in the master component you can leverage them like:

```tsx
export const CustomComponents = () => {
  return (
    <div
      style={{
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        padding: 20,
        margin: 20,
        background: '#02020F',
        borderRadius: 5
      }}
    >
      <Sessions sessions={fakeSessions}>
        <SessionsList>
          <NewSessionButton>
            <button className="text-blue-500">New Session</button>
          </NewSessionButton>
          <Divider />
          <SessionGroups>
            {groups =>
              groups.map(({ heading, sessions }) => (
                <SessionsGroup heading={heading} key={heading}>
                  {sessions.map(s => (
                    <SessionListItem key={s.id} session={s}>
                      <CustomSessionListItem session={s} />
                    </SessionListItem>
                  ))}
                </SessionsGroup>
              ))
            }
          </SessionGroups>
        </SessionsList>
        <div className="flex-1 h-full flex flex-col">
          <SessionMessages>
            <CustomSessionMessage />
          </SessionMessages>
          <SessionInput />
        </div>
      </Sessions>
    </div>
  );
};
```

### Using SessionContext
The `SessionContext` hook provides access to the current session state and methods to
interact with it. Here's how you can use it:

```tsx
import { useSessionContext } from 'reachat';

const CustomSendButton = () => {
  const { sendMessage } = useSessionContext();
  const handleSend = () => {
    sendMessage('Hello, AI!');
    return <button onClick={handleSend}>Send Custom Message</button>;
  };
};
```

The `SessionContext` hook provides the following properties and methods:

```ts
export interface SessionContextProps {
  sessions: Session[];
  activeSessionId: string | null;
  theme?: ChatTheme;
  isLoading?: boolean;
  activeSession?: Session | null;
  remarkPlugins?: PluggableList[];
  selectSession?: (sessionId: string) => void;
  deleteSession?: (sessionId: string) => void;
  createSession?: () => void;
}
```

By using these overrides and the `SessionContext` hook, you can create a fully customized chat
experience while still leveraging the core functionality of reachat.
